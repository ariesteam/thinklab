/**
 * Copyright 2011 The ARIES Consortium (http://www.ariesonline.org) and
 * www.integratedmodelling.org. 

   This file is part of Thinklab.

   Thinklab is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   Thinklab is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Thinklab.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.integratedmodelling.thinklab.geospace.extents;

import java.util.Collection;

import org.geotools.feature.FeatureCollection;
import org.geotools.geometry.jts.ReferencedEnvelope;
import org.integratedmodelling.collections.Pair;
import org.integratedmodelling.exceptions.ThinklabException;
import org.integratedmodelling.exceptions.ThinklabRuntimeException;
import org.integratedmodelling.exceptions.ThinklabValidationException;
import org.integratedmodelling.list.PolyList;
import org.integratedmodelling.thinklab.NS;
import org.integratedmodelling.thinklab.Thinklab;
import org.integratedmodelling.thinklab.api.knowledge.IConcept;
import org.integratedmodelling.thinklab.api.knowledge.IConceptualizable;
import org.integratedmodelling.thinklab.api.knowledge.IProperty;
import org.integratedmodelling.thinklab.api.knowledge.ISemanticObject;
import org.integratedmodelling.thinklab.api.lang.IList;
import org.integratedmodelling.thinklab.api.modelling.IEntifiable;
import org.integratedmodelling.thinklab.api.modelling.IExtent;
import org.integratedmodelling.thinklab.api.modelling.IModelObject;
import org.integratedmodelling.thinklab.api.modelling.IState;
import org.integratedmodelling.thinklab.geospace.Geospace;
import org.integratedmodelling.thinklab.geospace.coverage.VectorCoverage;
import org.integratedmodelling.thinklab.geospace.literals.ShapeValue;
import org.opengis.referencing.crs.CoordinateReferenceSystem;

import com.vividsolutions.jts.geom.Envelope;
import com.vividsolutions.jts.geom.Geometry;

/**
 * Shape extents are generated by vector-oriented contextualization strategies. Raster 
 * CMs should be capable of dealing with them too.
 * 
 * Because shapes are usually the spatial representation of physical entities, we implement
 * IEntifiable so that the shapes can be retrieved.
 * 
 * @author Ferdinando
 *
 */
public class ShapeExtent extends ArealExtent implements IEntifiable, IConceptualizable {

	// we either have one shape or a feature collection. If we see space as a collection of features, the
	// shape should be the convex hull of all features, but we don't compute it unless necessary.
	ShapeValue shape = null;
	FeatureCollection<?,?> features = null;
	private String featureURL;
	
	// only used for lineage so far
	private VectorCoverage coverage = null;
	
	public ShapeExtent() {
		
	}
	
	public ShapeExtent(ReferencedEnvelope envelope, CoordinateReferenceSystem crs) {
		super(crs, envelope.getMinX(), envelope.getMinY(), envelope.getMaxX(), envelope.getMaxY());
		// our overall shape is the bounding box
		this.shape = new ShapeValue(envelope);
	}
	
	public ShapeExtent(Geometry shape, Envelope envelope, CoordinateReferenceSystem crs) {
		super(crs, envelope.getMinX(), envelope.getMinY(), envelope.getMaxX(), envelope.getMaxY());
		this.shape = new ShapeValue(shape, crs);
	}

	public ShapeExtent(FeatureCollection<?,?> features, String sourceURL, ReferencedEnvelope envelope, CoordinateReferenceSystem crs) {
		super(crs, envelope.getMinX(), envelope.getMinY(), envelope.getMaxX(), envelope.getMaxY());
		this.features = features;
		this.featureURL = sourceURL;
		// our overall shape is the bounding box
		this.shape = new ShapeValue(envelope);
	}

	// this is used to create lineages so the original shapes can be reconstructed.
	public ShapeExtent(ArealExtent ex, VectorCoverage vectorCoverage) {
		super(ex.getCRS(),
			  ex.envelope.getMinX(), ex.envelope.getMinY(), ex.envelope.getMaxX(), ex.envelope.getMaxY());
		this.coverage  = vectorCoverage;
	}
	
	public ShapeExtent(ShapeValue shape) {
		super(shape.getCRS(), 
			  shape.getEnvelope().getMinX(), 
			  shape.getEnvelope().getMinY(), 
			  shape.getEnvelope().getMaxX(), 
			  shape.getEnvelope().getMaxY());
		this.shape = shape;
	}

//	@Override
	public ISemanticObject<?> getFullExtentValue() {
		return shape;
	}

	@Override
	public Object getValue(int granule) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public int getValueCount() {
		return features == null ? 1 : features.size();
	}
	
	/*
	 * FIXME this should get a shapevalue from above - not sure if it's used
	 * (non-Javadoc)
	 * @see org.integratedmodelling.geospace.extents.ArealExtent#getShape()
	 */
	public ShapeValue getShape() {
		return shape;
	}
	

	public void setFeatures(FeatureCollection<?,?> features, String sourceURL) {
		this.features = features;
		this.featureURL = sourceURL;
	}

	/*
	 * a fast way to check if the features are different, assuming features are read-only
	 */
	public boolean hasDifferentFeatures(ShapeExtent otextent) {

		boolean ret = false;
		
		if (features == null && otextent.features == null) {

			if (shape == null && otextent.shape == null)
				ret = false;
			else if (shape == null || otextent.shape == null) 
				ret = true;
			else
				ret = shape.equals(otextent.shape);
			
		} else if (features == null || otextent.features == null) {
			ret = true;
		} else {
			ret = !(this.featureURL.equals(otextent.featureURL));
		}
		return ret;
	}


//	@Override
//	public Polylist conceptualize() throws ThinklabException {
//		// TODO Auto-generated method stub
//		return null;
//	}

	@Override
	protected IExtent createMergedExtent(
			ArealExtent orextent, ArealExtent otextent,
			CoordinateReferenceSystem ccr, Envelope common,
			 Envelope orenvnorm, Envelope otenvnorm) {

		// TODO everything needs thorough checking
		ArealExtent ret = null;
		
		// if any is a GridExtent, or if we have two different feature collections, we need
		// to move this to a GridExtent.
		if (otextent instanceof GridExtent) {

			// raster wins TODO should use the common envelope for the grid extent.
			GridExtent gext = new GridExtent((GridExtent)otextent);
			
			/*
			 * TODO rasterize our features onto the activation layer of the grid.
			 */
			
			
			ret = gext;
			
		} else if (orextent instanceof ShapeExtent && ((ShapeExtent)orextent).hasDifferentFeatures((ShapeExtent)otextent)) {
			
			// we can't really handle this as a vector operation yet. 
			// Will determine a polygonal overlay at some point. For now we just turn to raster, but
			// we need a smart guess for the resolution.
			// should check that they're exactly the same, or again rasterize

			
		} else {
			
			// should check that they're exactly the same, or again rasterize
			Geometry s =
				((ShapeExtent)orextent).getShape().getGeometry().intersection(((ShapeExtent)otextent).getShape().getGeometry());
			Envelope env = s.getEnvelopeInternal();	
			ret = new ShapeExtent(s, env, getCRS());
			
		}

		return ret;
		
	}

	@Override
	protected IExtent createConstrainedExtent(
			ArealExtent orextent, ArealExtent otextent,
			CoordinateReferenceSystem ccr, Envelope common,
			 Envelope orenvnorm, Envelope otenvnorm) {

		return createMergedExtent(orextent, otextent, ccr, common, orenvnorm, otenvnorm);
	}

//	@Override
//	public IDatasourceTransformation getDatasourceTransformation(
//			IConcept mainObservable, IExtent extent) throws ThinklabException {
//		
//		IDatasourceTransformation ret = null;
//		
//		if (extent instanceof GridExtent) {
//			ret = new Rasterize((GridExtent) extent);
//		} else if (extent instanceof ShapeExtent) {
////			Geometry s =
////				((ShapeExtent)extent).getShape().intersection(this.getShape());
////			Envelope env = s.getEnvelopeInternal();	
////			ret = new ShapeExtent(s, env, getCRS());
//			
//			//throw new ThinklabValidationException("shape extent: cannot transform to extent " + extent);
//		}
//		return ret;
//	}

	@Override
	public IExtent getExtent(int granule) {
		// TODO Auto-generated method stub
		return null;
	}

//	@Override
	public String getSignature() {
		try {
			return 
				Geospace.getCRSIdentifier(crs, false) +
				"," +
				shape.getWKB();
		} catch (ThinklabException e) {
			throw new ThinklabRuntimeException(e);
		}
	}

//	@Override
//	public Collection<ISemanticLiteral> getEntities() throws ThinklabException {
//		
//		ArrayList<ISemanticLiteral> ret = new ArrayList<ISemanticLiteral>();
//		if (features != null) {
//		
//			/*
//			 * retrieve our shapes, cut appropriately for the bounding box. We need to use
//			 * a lazy collection here, we may have thousands of these.
//			 */
//			return 
//				new LazyShapeCollection(coverage.getFeatureIterator(envelope, (String[])null), crs);
//			
//		} else {
//			ret.add(shape);
//		}
//		return ret;
//	}
//
//	@Override
//	public IExtent or(IExtent myExtent) {
//		// TODO Auto-generated method stub
//		return null;
//	}
//
//	@Override
//	public IExtent getAggregatedExtent() {
//		return new ShapeExtent(shape);
//	}

	@Override
	public Collection<Pair<String, Integer>> getStateLocators(int index) {
		// TODO Auto-generated method stub
		return null;
	}

//	@Override
//	public boolean checkDomainDiscontinuity() throws ThinklabException {
//		// TODO this is tough if we need to check contiguity, the point is
//		// it's most often discontinuous unless there is one shape or full coverage.
//		return false;
//	}
//
//	@Override
//	public IExtent intersection(IExtent extent) throws ThinklabException {
//		// TODO this one is tough
//		return extent;
//	}

	@Override
	public IExtent force(IExtent extent) throws ThinklabException {
		return extent;
	}

//	@Override
//	public IExtent union(IExtent extent) throws ThinklabException {
//		// TODO Auto-generated method stub
//		return null;
//	}

	public String toString() {
		return "shape-extent(" + envelope + "," + crs.getName() + " @ " + shape + ")";
	}

//	@Override
//	public IConcept getValueType() {
//		// TODO the concept corresponding to the shape in a ShapeValue.
//		return null;
//	}
//
//	@Override
//	public Restriction getConstraint(String operator) throws ThinklabException {
//		return new Restriction("boundingbox", operator, getFullExtentValue().toString());
//	}
//
//	@Override
//	public AggregationParameters getAggregationParameters(IConcept concept,
//			Unit unit) {
//		// TODO Auto-generated method stub
//		return null;
//	}

	@Override
	public boolean isCovered(int granule) {
		
		// TODO check - for now we assume all features are not null, and 
		// if we iterate over features the n-th feature is always covered.
		return true;
	}

	@Override
	public IExtent collapse() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public boolean isDiscontinuous() throws ThinklabException {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public Object getRawData() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public double[] getDataAsDoubles() throws ThinklabValidationException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public double getDoubleValue(int index) throws ThinklabValidationException {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public IState aggregate(IConcept concept) throws ThinklabException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public int getMultiplicity() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public IExtent intersection(IExtent other) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public IExtent union(IExtent other) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public boolean contains(IExtent o) throws ThinklabException {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean overlaps(IExtent o) throws ThinklabException {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean intersects(IExtent o) throws ThinklabException {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public Collection<IModelObject> getEntities() throws ThinklabException {
		// TODO Auto-generated method stub
		return null;
	}

//	@Override
//	public double getTotalAreaSquareMeters() {
//		// TODO Auto-generated method stub
//		return 0;
//	}
	
	/*
	 * TODO >1 shapes
	 * (non-Javadoc)
	 * @see org.integratedmodelling.thinklab.api.knowledge.IConceptualizable#conceptualize()
	 */
	@Override
	public IList conceptualize() throws ThinklabException {
		
		return PolyList.listNotNull(
				Thinklab.c(NS.SHAPE_EXTENT),
				PolyList.list(Thinklab.p(NS.GEOSPACE_HAS_MINX), envelope.getMinX()),
				PolyList.list(Thinklab.p(NS.GEOSPACE_HAS_MAXX), envelope.getMaxX()),
				PolyList.list(Thinklab.p(NS.GEOSPACE_HAS_MINY), envelope.getMinY()),
				PolyList.list(Thinklab.p(NS.GEOSPACE_HAS_MAXY), envelope.getMaxY()),
				PolyList.list(Thinklab.p(NS.GEOSPACE_HAS_CRSCODE), Geospace.getCRSIdentifier(crs, true)),
				(shape == null ? 
						null :
						PolyList.list(NS.GEOSPACE_HAS_SHAPE, shape)));
	}

	/*
	 * TODO >1 shapes
	 * (non-Javadoc)
	 * @see org.integratedmodelling.thinklab.api.knowledge.IConceptualizable#define(org.integratedmodelling.thinklab.api.lang.IList)
	 */
	@Override
	public void define(IList conceptualization) throws ThinklabException {

		double xmax, xmin, ymax, ymin;
		String crsId;
		ShapeValue shp = null;
		
		for (Object o : conceptualization.toArray()) {
			if (o instanceof IList) {
				IProperty p = (IProperty)((IList)o).first();
				if (p.equals(NS.GEOSPACE_HAS_MAXX)) {
					xmax = (Double) ((IList)o).nth(1);
				} else if (p.equals(NS.GEOSPACE_HAS_MAXY)) {
					ymax = (Double) ((IList)o).nth(1);
				} else if (p.equals(NS.GEOSPACE_HAS_MINX)) {
					xmin = (Double) ((IList)o).nth(1);
				} else if (p.equals(NS.GEOSPACE_HAS_MINY)) {
					ymin = (Double) ((IList)o).nth(1);
				} else if (p.equals(NS.GEOSPACE_HAS_CRSCODE)) {
					crsId = (String) ((IList)o).nth(1);
				} else if (p.equals(NS.GEOSPACE_HAS_SHAPE)) {
					shp = (ShapeValue) ((IList)o).nth(1);
				} 
			}
		}
		
		/*
		 * TODO setup
		 */
	}

}
